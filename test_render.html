<!DOCTYPE html>
<html>
<head>
    <title>Xunfei Avatar RTC Player</title>

    <script id="qwebchannel-script"></script>
    <script id="rtc-player-script"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
        }
        #video-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #rtc-video {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
            display: block !important;
            z-index: 1;
        }
        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
        }
        .status-success { color: #00FF00; }
        .status-failure { color: #FF6347; }
        .status-warning { color: yellow; }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="rtc-video" autoplay controls muted style="display: block;"></video>
    </div>

    <div id="status-bar">
        JS Status: <span id="jsStatus"></span> |
        Player Status: <span id="playerStatus">Initializing...</span>
    </div>

    <script>
        let pyHandler;
        let rtcPlayer;

        const jsStatus = document.getElementById('jsStatus');
        const playerStatus = document.getElementById('playerStatus');
        const videoElement = document.getElementById('rtc-video');

        function findRTCPlayerClass() {
            if (typeof Interactive !== 'undefined' && typeof Interactive.RTCPlayer === 'function') {
                return Interactive.RTCPlayer;
            }
            if (typeof RTCPlayer === 'function') {
                return RTCPlayer;
            }
            return null;
        }

        /**
         * 注册播放器事件监听器，用于更精细的诊断。
         */
        function registerPlayerListeners(player) {

            // 监听连接状态变化 (如 WebRTC/XRTC 连接成功)
            player.onConnect = (data) => {
                pyHandler.log('【Player Event】onConnect: 媒体流连接成功（信令已完成）。');
                playerStatus.innerHTML = '<span class="status-success">✅ Stream CONNECTED!</span>';
            };

            // 监听视频元素开始播放事件 (表示数据已接收且正在解码)
            videoElement.addEventListener('play', () => {
                pyHandler.log('【Video Event】Video Element is now PLAYING (Data is flowing).');
                // 此时黑屏意味着编解码器失败
                playerStatus.innerHTML = '<span class="status-warning">⚠️ Stream PLAYING, CHECKING CODEC...</span>';
            });

            // 监听视频元素的第一帧渲染
            videoElement.addEventListener('playing', () => {
                pyHandler.log('【Video Event】Video Element received FIRST FRAME!');
                playerStatus.innerHTML = '<span class="status-success">✅ VIDEO IS RENDERING!</span>';
            });

            // 监听视频元素加载元数据 (通常在连接成功后很快发生)
            videoElement.addEventListener('loadedmetadata', () => {
                pyHandler.log(`【Video Event】Loaded Metadata: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
            });

            // 监听错误
            player.onStatusChange = (status) => {
                pyHandler.log(`【Player Event】Status Change: ${JSON.stringify(status)}`);
            };

            player.onError = (err) => {
                pyHandler.log(`【Player Event】FATAL Error: ${JSON.stringify(err)}`);
                playerStatus.innerHTML = `<span class="status-failure">❌ Player Fatal Error: ${err.message || JSON.stringify(err)}</span>`;
            };

            // 监听网络错误
            videoElement.addEventListener('error', (e) => {
                const errMsg = e.target.error ? e.target.error.message : 'Unknown Video Error';
                pyHandler.log(`【Video Error】Video Element Error: ${e.target.error.code} - ${errMsg}`);
            });
        }


        /**
         * 接收 Python 传递的流信息，并初始化播放器。
         */
        function onStreamUrlReady(streamInfoJson) {
            pyHandler.log('Received stream URL from Python, attempting to initialize player...');

            const RTCPlayerClass = findRTCPlayerClass();

            if (RTCPlayerClass) {
                playerStatus.innerHTML = '<span class="status-success">✅ RTCPlayer FOUND!</span>';

                try {
                    const streamInfo = JSON.parse(streamInfoJson);

                    if (rtcPlayer && typeof rtcPlayer.destroy === 'function') {
                        rtcPlayer.destroy();
                        pyHandler.log('Destroyed old rtcPlayer instance.');
                    }

                    videoElement.style.display = 'block';

                    const playerConfig = {
                        url: streamInfo.streamUrl,
                        container: document.getElementById('video-container'),
                        videoElement: videoElement,
                        playerType: streamInfo.playerType || 12,
                    };

                    rtcPlayer = new RTCPlayerClass(playerConfig);
                    registerPlayerListeners(rtcPlayer); // 注册监听器

                    // 【核心修正】：设置 XRTC 专属配置对象 (基于 XrtcPlayer.vue)
                    if (streamInfo.xrtcStreamConfig) {
                        // 赋值给 rtcPlayer.stream 属性，这是 XRTC 协议的正确入会认证方式
                        rtcPlayer.stream = streamInfo.xrtcStreamConfig;
                        pyHandler.log(`【XRTC Config】Assigned stream config to rtcPlayer.stream (PlayerType 12).`);
                    } else {
                        pyHandler.log(`【ERROR】Missing xrtcStreamConfig! XRTC stream may fail.`);
                    }

                    pyHandler.log('RTCPlayer instance created. Attempting to play...');

                    rtcPlayer.play().then(() => {
                        pyHandler.log('RTCPlayer play() promise resolved (Signaling Complete).');

                        videoElement.muted = true;
                        videoElement.play();

                    }).catch(err => {
                        playerStatus.innerHTML = `<span class="status-failure">❌ Play Error: ${err.name}: ${err.message}</span>`;
                        pyHandler.log(`【JS ERROR】RTCPlayer play() failed: ${err.name}: ${err.message}`);
                    });

                } catch (e) {
                    playerStatus.innerHTML = `<span class="status-failure">❌ Initialization Error: ${e.message}</span>`;
                    pyHandler.log(`【JS FATAL】播放器初始化逻辑失败: ${e.message}. Stack: ${e.stack}`);
                }

            } else {
                const errorMsg = '未找到 Interactive.RTCPlayer 或其他播放器类。';
                pyHandler.log(`【致命错误】RTC 播放器库: ${errorMsg}`);
                playerStatus.innerHTML = `<span class="status-failure">❌ ${errorMsg}</span>`;
            }
        }

        function initQWebChannel() {
            if (typeof qt === 'undefined' || typeof QWebChannel === 'undefined') {
                jsStatus.innerHTML = '<span class="status-warning">Waiting for Python Bridge...</span>';
                setTimeout(initQWebChannel, 50);
                return;
            }

            new QWebChannel(qt.webChannelTransport, function (channel) {
                pyHandler = channel.objects.pyHandler;
                pyHandler.streamUrlReady.connect(onStreamUrlReady);

                pyHandler.log('HTML and QWebChannel initialized. Waiting for stream URL...');
                jsStatus.innerHTML = '<span class="status-success">✅ QWebChannel Initialized.</span>';
            });
        }

        initQWebChannel();

    </script>
</body>
</html>